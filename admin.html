<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <base target="_top">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Works Admin</title>
    <style>
        :root {
            --bg: #faf7f2;
            --paper: #fff;
            --ink: #2f2a28;
            --frame: #e6dccf;
            --accent: #b86b5e;
        }

        body {
            font: 14px/1.45 system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
            margin: 18px;
            color: var(--ink);
            background: var(--bg)
        }

        h1 {
            margin: 0 0 10px
        }

        .toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
            margin: 12px 0 16px
        }

        .toolbar>* {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 8px 10px
        }

        .toolbar select,
        .toolbar input {
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 6px 8px
        }

        .btn {
            cursor: pointer
        }

        .btn.primary {
            background: var(--accent);
            color: #fff;
            border-color: var(--accent)
        }

        .btn.danger {
            background: #a33;
            color: #fff;
            border-color: #a33
        }

        .status {
            margin-left: 8px
        }

        .tabs {
            display: flex;
            gap: 8px;
            margin: 10px 0;
            flex-wrap: wrap
        }

        .tabs button {
            padding: 6px 10px;
            border-radius: 8px;
            border: 1px solid #ccc;
            background: #fff;
            cursor: pointer
        }

        .tabs button[aria-pressed="true"] {
            background: var(--accent);
            color: #fff;
            border-color: var(--accent)
        }

        .row {
            display: flex;
            gap: 20px;
            flex-wrap: wrap
        }

        .col {
            flex: 1 1 420px;
            background: #fff;
            border: 1px solid var(--frame);
            border-radius: 12px;
            padding: 12px
        }

        ul {
            list-style: none;
            margin: 0;
            padding: 0;
            border: 1px dashed #d8cec0;
            border-radius: 8px;
            min-height: 240px;
            background: #fff
        }

        li {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            border-bottom: 1px solid #eee;
            cursor: grab
        }

        li:last-child {
            border-bottom: 0
        }

        li.dragging {
            opacity: .5
        }

        .thumb {
            width: 64px;
            height: 48px;
            object-fit: cover;
            border-radius: 6px;
            background: #f2f2f2
        }

        .grow {
            flex: 1
        }

        .muted {
            color: #777
        }

        .small {
            font-size: 12px
        }

        .dangerTxt {
            color: #a00
        }
    </style>
</head>

<body>
    <h1>Works Admin</h1>

    <div class="toolbar">
        <div>
            <label class="small">Upload to category:
                <select id="catSel"></select>
            </label>
            <input id="files" type="file" multiple accept="image/*">
            <button id="uploadBtn" class="btn">Upload</button>
        </div>
        <button id="saveBtn" class="btn primary">Save Order</button>
        <span id="status" class="status muted"></span>
    </div>

    <div id="tabs" class="tabs"></div>
    <div id="lists" class="row"></div>

    <p class="small muted">
        ・<b>All</b> は全カテゴリの順序です（サイトの「All」表示順に使用）。<br>
        ・各カテゴリタブでは、そのカテゴリ内部の順序を変更できます。<br>
        ・🗑 の削除は GitHub からファイルを消し、manifest からも除外します（元に戻すときは Git のコミット履歴から復元可）。
    </p>

    <script>
        let manifest = {};
        let current = 'all';

        // Web App base URL (auto-injected by GAS). If you open this page outside GAS,
        // the PHP-like scriptlet will still render a literal string, which we detect.
        const EXEC_URL = '<?= ScriptApp.getService().getUrl(); ?>';
        // Detect if we are in GAS HtmlService (google.script.run exists)
        const HAS_GSR = !!(window.google && google.script && google.script.run);

        // -------------- Helpers (UI) --------------
        function el(tag, props = {}, ...kids) {
            const n = document.createElement(tag);
            Object.assign(n, props);
            for (const k of kids) n.append(k);
            return n;
        }
        function setStatus(t, isErr = false) {
            const el = document.getElementById('status');
            el.textContent = t;
            el.className = 'status ' + (isErr ? 'dangerTxt' : 'muted');
        }

        // -------------- Data access (GSR or REST fallback) --------------
        function gsGetManifest() {
            return new Promise((resolve, reject) => {
                google.script.run.withSuccessHandler(m => resolve(m || {}))
                    .withFailureHandler(reject)
                    .getManifestObj();
            });
        }
        function restGetManifest() {
            return fetch(EXEC_URL + '?endpoint=manifest', { method: 'GET', credentials: 'omit' })
                .then(r => { if (!r.ok) throw new Error('manifest GET failed'); return r.json(); });
        }
        function loadManifest() {
            if (HAS_GSR) return gsGetManifest().then(m => manifest = withDefaults(m));
            // fallback
            return restGetManifest().then(m => manifest = withDefaults(m));
        }

        function gsSaveManifest() {
            return new Promise((resolve, reject) => {
                google.script.run.withSuccessHandler(res => res && res.ok ? resolve() : reject(new Error('save failed')))
                    .withFailureHandler(reject)
                    .saveManifest(manifest);
            });
        }
        function restSaveManifest() {
            return fetch(EXEC_URL + '?endpoint=update-order', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ manifest })
            }).then(r => r.json()).then(res => {
                if (!res.ok) throw new Error('save failed');
            });
        }
        function saveOrder() { return HAS_GSR ? gsSaveManifest() : restSaveManifest(); }

        function gsDeleteOne(category, name) {
            return new Promise((resolve, reject) => {
                google.script.run.withSuccessHandler(res => res && res.ok ? resolve() : reject(new Error('delete failed')))
                    .withFailureHandler(reject)
                    .deleteOne(category, name);
            });
        }
        function restDeleteOne(category, name) {
            return fetch(EXEC_URL + '?endpoint=delete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ category, name })
            }).then(r => r.json()).then(res => {
                if (!res.ok) throw new Error('delete failed');
            });
        }
        function delOne(category, name) { return HAS_GSR ? gsDeleteOne(category, name) : restDeleteOne(category, name); }

        // -------------- Manifest shaping --------------
        const DEFAULT_CATEGORIES = ['aquarelles', 'flowers', 'landscapes', 'pets', 'portraits'];
        function withDefaults(m) {
            m = m || {};
            DEFAULT_CATEGORIES.forEach(c => { if (!Array.isArray(m[c])) m[c] = []; });
            if (!Array.isArray(m._allOrder)) m._allOrder = [];
            return m;
        }

        // -------------- Rendering --------------
        function renderTabs() {
            const tabs = document.getElementById('tabs');
            tabs.innerHTML = '';
            const cats = Object.keys(manifest).filter(k => k !== '_allOrder');
            const tabList = ['all', ...cats];
            tabList.forEach(cat => {
                const label = cat === 'all' ? 'All' : cat;
                const b = el('button', { textContent: label, onclick() { current = cat; renderLists(); } });
                b.setAttribute('aria-pressed', cat === current);
                tabs.append(b);
            });

            // upload category selector
            const sel = document.getElementById('catSel');
            sel.innerHTML = cats.map(c => `<option>${c}</option>`).join('');
            if (cats.length && !sel.value) sel.value = cats[0];
        }

        function makeLi(cat, name, allowDrag = true) {
            const li = el('li', { draggable: allowDrag });
            if (allowDrag) {
                li.addEventListener('dragstart', () => li.classList.add('dragging'));
                li.addEventListener('dragend', () => li.classList.remove('dragging'));
            }
            const img = el('img', { className: 'thumb', src: `assets/works/${cat}/${encodeURIComponent(name)}` });
            const title = (current === 'all') ? `[${cat}] ${name}` : name;
            const del = el('button', {
                className: 'btn danger small', textContent: '🗑', onclick: async () => {
                    if (!confirm(`Delete this image?\n${cat}/${name}`)) return;
                    setStatus('Deleting...');
                    try {
                        await delOne(cat, name);
                        // remove from local state
                        if (manifest[cat]) manifest[cat] = manifest[cat].filter(n => n !== name);
                        manifest._allOrder = (manifest._allOrder || []).filter(p => p !== `${cat}/${name}`);
                        renderLists();
                        setStatus('Deleted ✅');
                    } catch (e) {
                        console.error(e); setStatus('Delete failed', true);
                    }
                }
            });
            li.append(img, el('span', { className: 'grow', textContent: title }), del);
            return li;
        }

        function enableDnd(ul, onChange) {
            ul.addEventListener('dragover', e => {
                e.preventDefault();
                const after = getDragAfterElement(ul, e.clientY);
                const dragging = ul.querySelector('.dragging');
                if (!dragging) return;
                if (after == null) ul.appendChild(dragging);
                else ul.insertBefore(dragging, after);
            });
            ul.addEventListener('drop', () => {
                onChange(Array.from(ul.querySelectorAll('li .grow')).map(s => s.textContent));
            });
        }

        function getDragAfterElement(container, y) {
            const els = [...container.querySelectorAll('li:not(.dragging)')];
            return els.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) return { offset, element: child };
                else return closest;
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        function renderLists() {
            const lists = document.getElementById('lists');
            lists.innerHTML = '';

            if (current === 'all') {
                const ul = el('ul', { id: 'ul-all' });
                // build ordered list from _allOrder + any missing tails
                const seen = new Set(manifest._allOrder || []);
                const rest = [];
                Object.entries(manifest).forEach(([cat, arr]) => {
                    if (cat === '_allOrder') return;
                    for (const name of arr) {
                        const key = `${cat}/${name}`;
                        if (!seen.has(key)) rest.push(key);
                    }
                });
                const ordered = [...(manifest._allOrder || []), ...rest];
                for (const key of ordered) {
                    const [cat, ...nameParts] = key.split('/');
                    const name = nameParts.join('/');
                    if (!manifest[cat] || !manifest[cat].includes(name)) continue;
                    ul.append(makeLi(cat, name, true));
                }
                enableDnd(ul, () => {
                    // Rebuild _allOrder from the images actually in the list (read src)
                    const keys = Array.from(ul.querySelectorAll('li img')).map(img => {
                        const m = img.getAttribute('src').match(/assets\/works\/([^/]+)\/(.+)$/);
                        return m ? `${decodeURIComponent(m[1])}/${decodeURIComponent(m[2])}` : null;
                    }).filter(Boolean);
                    manifest._allOrder = keys;
                    setStatus('All order changed (not saved yet)');
                });
                lists.append(el('div', { className: 'col' }, el('h3', { textContent: 'All (drag to reorder)' }), ul));
                return;
            }

            // Per-category
            if (!manifest[current]) {
                lists.append(el('div', { className: 'col' }, el('p', { className: 'muted', textContent: 'No items in this category.' })));
                return;
            }
            const ul = el('ul', { id: 'ul-' + current });
            (manifest[current] || []).forEach(name => ul.append(makeLi(current, name, true)));
            enableDnd(ul, (names) => {
                manifest[current] = names;
                setStatus('Order changed (not saved yet)');
            });

            // Preview
            const preview = el('div', { className: 'small' });
            Object.entries(manifest).forEach(([cat, arr]) => {
                if (cat === '_allOrder') return;
                preview.append(
                    el('div', {},
                        el('strong', { textContent: cat + ` (${arr.length})` }),
                        el('div', { className: 'muted' }, document.createTextNode(arr.join(', ')))
                    )
                );
            });

            lists.append(
                el('div', { className: 'col' }, el('h3', { textContent: 'Reorder: ' + current }), ul),
                el('div', { className: 'col' }, el('h3', { textContent: 'Manifest preview' }), preview)
            );
        }

        // -------------- Events --------------
        async function onSaveClick() {
            try { setStatus('Saving...'); await saveOrder(); setStatus('Saved ✅'); }
            catch (e) { console.error(e); setStatus('Save failed', true); }
        }

        async function onUploadClick() {
            const sel = document.getElementById('catSel');
            const cat = sel.value;
            const inp = document.getElementById('files');
            if (!cat) return setStatus('Choose category', true);
            if (!inp.files.length) return setStatus('Select files first', true);

            const fd = new FormData();
            fd.append('category', cat);
            for (const f of inp.files) fd.append('files', f, f.name);

            try {
                setStatus('Uploading...');
                const r = await fetch(EXEC_URL + '?endpoint=upload', { method: 'POST', body: fd, credentials: 'omit' });
                if (!r.ok) throw new Error('upload failed');
                await loadManifest();
                renderTabs();
                renderLists();
                inp.value = '';
                setStatus('Uploaded ✅');
            } catch (e) {
                console.error(e); setStatus('Upload failed', true);
            }
        }

        // -------------- Init --------------
        (async function () {
            try {
                await loadManifest();
                renderTabs();
                renderLists();
                setStatus('Ready');
            } catch (e) {
                console.error(e);
                setStatus('Failed to load manifest', true);
            }
            document.getElementById('saveBtn').addEventListener('click', onSaveClick);
            document.getElementById('uploadBtn').addEventListener('click', onUploadClick);
        })();
    </script>
</body>

</html>